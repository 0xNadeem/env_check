#!/usr/bin/env ruby
# frozen_string_literal: true

# bin/env_check - CLI for EnvCheck gem

require "optparse"
require "fileutils"

# Ensure we can load the gem whether it's installed or in development
begin
  require "env_check"
rescue LoadError
  # If we can't load the gem, try to add lib to load path (for development)
  lib_path = File.expand_path("../lib", __dir__)
  $LOAD_PATH.unshift(lib_path) unless $LOAD_PATH.include?(lib_path)
  require "env_check"
end

# Module for CLI output helpers
module CLIHelpers
  def success(message)
    puts message unless @options[:quiet]
  end

  def info(message)
    puts message unless @options[:quiet]
  end

  def warning(message)
    puts "⚠️  #{message}" unless @options[:quiet]
  end

  def error(message)
    warn message
  end

  def error_exit(message, code = 1)
    warn "Error: #{message}"
    exit code
  end

  def default_config_path
    Dir.exist?("config") ? "config/env_check.yml" : ".env_check.yml"
  end
end

# CLI class for better organization
class EnvCheckCLI
  include CLIHelpers
  def initialize(args = ARGV)
    @args = args
    @options = {
      config: nil, # Will be auto-discovered if not specified
      quiet: false,
      verbose: false
    }
    @command = nil
  end

  def run
    parse_arguments
    execute_command
  rescue StandardError => e
    error_exit(e.message.to_s)
  end

  private

  def parse_arguments
    parser = create_option_parser
    parser.parse!(@args)
    @command = @args.shift
  end

  def create_option_parser
    OptionParser.new do |opts|
      configure_banner_and_commands(opts)
      configure_options(opts)
    end
  end

  def configure_banner_and_commands(opts)
    opts.banner = "Usage: env_check [options] <command>"
    opts.separator ""
    opts.separator "Commands:"
    opts.separator "  init     Create a new env_check.yml configuration file"
    opts.separator "  check    Validate environment variables against configuration"
    opts.separator "  version  Show version number"
    opts.separator ""
    opts.separator "Options:"
  end

  def configure_options(opts)
    opts.on("-c", "--config PATH",
            "Configuration file path (auto-discovered: .env_check.yml or config/env_check.yml)") do |path|
      @options[:config] = path
    end

    opts.on("-q", "--quiet", "Suppress output (only show errors)") do
      @options[:quiet] = true
    end

    opts.on("-v", "--verbose", "Show detailed output") do
      @options[:verbose] = true
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      exit 0
    end
  end

  def execute_command
    case @command
    when "init"
      init_command
    when "check"
      check_command
    when "version"
      version_command
    when nil
      show_help_and_exit
    else
      error_exit("Unknown command: #{@command}")
    end
  end

  def init_command
    path = @options[:config] || determine_init_path

    begin
      # Create directory if it doesn't exist
      dir = File.dirname(path)
      FileUtils.mkdir_p(dir) unless dir == "."

      if File.exist?(path)
        warning("Configuration file already exists: #{path}")
        return
      end

      create_config_file(path)
      success("Created configuration file: #{path}")

      unless @options[:quiet]
        puts "\nNext steps:"
        puts "1. Edit #{path} to define your required environment variables"
        puts "2. Run 'env_check check' to validate your environment"
      end
    rescue StandardError => e
      error_exit("Failed to create configuration file: #{e.message}")
    end
  end

  def check_command
    path = @options[:config] || EnvCheck::Config.discover_config_path
    validate_config_exists(path)

    info("Checking environment variables using: #{path}") if @options[:verbose]

    result = perform_validation(path)
    handle_validation_result(result)
  end

  def validate_config_exists(path)
    return if File.exist?(path)

    error_exit("Configuration file not found: #{path}. Run 'env_check init' first.")
  end

  def perform_validation(path)
    EnvCheck.verify(path)
  rescue EnvCheck::Error => e
    error_exit("Validation failed: #{e.message}")
  rescue StandardError => e
    error_exit("Unexpected error: #{e.message}")
  end

  def handle_validation_result(result)
    if result.success?
      handle_success_result(result)
    else
      handle_failure_result(result)
    end
  end

  def handle_success_result(result)
    success("✅ All environment variables are valid!")

    if @options[:verbose] && !result.valid_vars.empty?
      puts "\nValid variables:"
      result.valid_vars.each { |var| puts "  ✅ #{var}" }
    end

    display_warnings(result.warnings) unless result.warnings.empty?
  end

  def handle_failure_result(result)
    error("❌ Environment validation failed!")

    display_errors(result.errors) unless result.errors.empty?
    display_warnings(result.warnings) unless result.warnings.empty?

    exit 1
  end

  def display_errors(errors)
    puts "\nErrors:"
    errors.each { |error| puts "  ❌ #{error}" }
  end

  def display_warnings(warnings)
    puts "\nWarnings:"
    warnings.each { |warning| puts "  ⚠️  #{warning}" }
  end

  def version_command
    puts EnvCheck::VERSION
  end

  def create_config_file(path)
    File.write(path, config_template)
  end

  def config_template
    <<~YAML
      # EnvCheck Configuration
      # Configure required and optional environment variables for your application

      # Required environment variables (must be present and non-empty)
      required:
        - DATABASE_URL
        - SECRET_KEY_BASE

      # Optional environment variables with type validation
      optional:
        DEBUG: boolean          # true, false, 1, 0, yes, no, on, off (case-insensitive)
        PORT: port             # valid port number (1-65535)
        API_URL: url           # must start with http:// or https://
        ADMIN_EMAIL: email     # valid email format
        LOG_LEVEL: string      # any string value
        RATE_LIMIT: float      # floating point number
        CONFIG_PATH: path      # file or directory path
        SETTINGS: json         # valid JSON string
      #{"  "}
      # You can also configure per-environment settings:
      # development:
      #   required:
      #     - DATABASE_URL
      #   optional:
      #     DEBUG: boolean
      ##{" "}
      # production:
      #   required:
      #     - DATABASE_URL
      #     - SECRET_KEY_BASE
      #     - RAILS_MASTER_KEY
      #   optional:
      #     REDIS_URL: url
    YAML
  end

  def show_help_and_exit
    puts create_option_parser.help
    exit 1
  end

  # Determine the best path for init command
  def determine_init_path
    default_config_path
  end
end

# Run the CLI
EnvCheckCLI.new.run if __FILE__ == $PROGRAM_NAME
